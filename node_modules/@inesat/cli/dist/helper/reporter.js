"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const filesize_1 = __importDefault(require("filesize"));
const gzip_size_1 = require("gzip-size");
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const recursive_readdir_1 = __importDefault(require("recursive-readdir"));
const store_1 = __importDefault(require("./store"));
//
const WARN_AFTER_BUNDLE_GZIP_SIZE = 512 * 1024;
const WARN_AFTER_CHUNK_GZIP_SIZE = 1024 * 1024;
//
class Reporter {
    canReadAsset(asset) {
        return (/\.(js|css)$/.test(asset) && !/service-worker\.js/.test(asset) && !/precache-manifest\.[0-9a-f]+\.js/.test(asset));
    }
    removeFileNameHash(buildFolder, fileName) {
        return fileName
            .replace(buildFolder, '')
            .replace(/\\/g, '/')
            .replace(/\/?(.*)(\.[0-9a-f]+)(\.chunk)?(\.js|\.css)/, (match, p1, p2, p3, p4) => p1 + p4);
    }
    // Input: 1024, 2048
    // Output: "(+1 KB)"
    getDifferenceLabel(currentSize, previousSize) {
        const FIFTY_KILOBYTES = 1024 * 50;
        const difference = currentSize - previousSize;
        const fileSize = !Number.isNaN(difference) ? (0, filesize_1.default)(difference) : 0;
        if (difference >= FIFTY_KILOBYTES) {
            return chalk_1.default.red('+' + fileSize);
        }
        else if (difference < FIFTY_KILOBYTES && difference > 0) {
            return chalk_1.default.yellow('+' + fileSize);
        }
        else if (difference < 0) {
            return chalk_1.default.green(fileSize);
        }
        else {
            return '';
        }
    }
    recursiveAsync(buildFolder) {
        return new Promise((resolve, reject) => {
            (0, recursive_readdir_1.default)(buildFolder, (e, fileNames) => {
                if (e)
                    return reject(e);
                resolve(fileNames);
            });
        });
    }
    async measureFileSizesBeforeBuild(buildFolder = store_1.default.outDir) {
        console.time('Spend Time');
        const fileNames = await this.recursiveAsync(buildFolder);
        let sizes;
        if (fileNames) {
            sizes = fileNames.filter(this.canReadAsset).reduce((memo, fileName) => {
                const contents = fs_1.default.readFileSync(fileName);
                const key = this.removeFileNameHash(buildFolder, fileName);
                memo[key] = (0, gzip_size_1.sync)(contents);
                return memo;
            }, {});
        }
        this.previousSizeMap = {
            root: buildFolder,
            sizes: sizes || {},
        };
    }
    printFileSizesAfterBuild(webpackStats, buildFolder = store_1.default.outDir, maxBundleGzipSize = WARN_AFTER_BUNDLE_GZIP_SIZE, maxChunkGzipSize = WARN_AFTER_CHUNK_GZIP_SIZE) {
        const { previousSizeMap } = this;
        const root = previousSizeMap.root;
        const sizes = previousSizeMap.sizes;
        let assets = (webpackStats.stats || [webpackStats]).map((stats) => stats
            .toJson({ assets: true })
            .assets.filter((asset) => this.canReadAsset(asset.name))
            .map((asset) => {
            const fileContents = fs_1.default.readFileSync(path_1.default.join(root, asset.name));
            const size = (0, gzip_size_1.sync)(fileContents);
            const previousSize = sizes[this.removeFileNameHash(root, asset.name)];
            const difference = this.getDifferenceLabel(size, previousSize);
            return {
                folder: path_1.default.join(path_1.default.basename(buildFolder), path_1.default.dirname(asset.name)),
                name: path_1.default.basename(asset.name),
                size: size,
                sizeLabel: (0, filesize_1.default)(size) + (difference ? ' (' + difference + ')' : ''),
            };
        }));
        assets = assets.reduce((single, all) => all.concat(single), []);
        assets = assets.sort((a, b) => b.size - a.size);
        const longestSizeLabelLength = Math.max.apply(null, assets.map((a) => (0, strip_ansi_1.default)(a.sizeLabel).length));
        // let suggestBundleSplitting = false
        assets.forEach((asset) => {
            let sizeLabel = asset.sizeLabel;
            const sizeLength = (0, strip_ansi_1.default)(sizeLabel).length;
            if (sizeLength < longestSizeLabelLength) {
                const rightPadding = ' '.repeat(longestSizeLabelLength - sizeLength);
                sizeLabel += rightPadding;
            }
            const isMainBundle = asset.name.indexOf('main.') === 0;
            const maxRecommendedSize = isMainBundle ? maxBundleGzipSize : maxChunkGzipSize;
            const isLarge = maxRecommendedSize && asset.size > maxRecommendedSize;
            /*  if (isLarge && path.extname(asset.name) === '.js') {
              suggestBundleSplitting = true
            } */
            console.log(`${isLarge ? chalk_1.default.yellow(sizeLabel) : sizeLabel} ${chalk_1.default.dim(asset.folder + path_1.default.sep)}${chalk_1.default.cyan(asset.name)}`);
        });
        console.log('\t');
        /* if (suggestBundleSplitting) {
          console.log()
          console.log(chalk.yellow('The bundle size is significantly larger than recommended.'))
          console.log(chalk.yellow('Consider reducing it with code splitting: https://goo.gl/9VhYWB'))
          console.log(chalk.yellow('You can also analyze the project dependencies: https://goo.gl/LeUzfb'))
        } */
        console.timeEnd('Spend Time');
    }
}
exports.default = new Reporter();
//# sourceMappingURL=reporter.js.map