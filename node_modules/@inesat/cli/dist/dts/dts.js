"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const getTSConfig_1 = require("./getTSConfig");
const getTSService_1 = require("./getTSService");
const path_1 = __importDefault(require("path"));
const store_1 = __importDefault(require("../helper/store"));
// import logger from 'src/helper/logger'
const fs_extra_1 = __importDefault(require("fs-extra"));
const transform_1 = require("./transform");
class DTSEmitFile {
    constructor() {
        this.lib = { code: '', key: [] };
        this.inesatCliFilename = '';
        this.libFilename = '';
        this.tsconfig = (0, getTSConfig_1.getTSConfig)(store_1.default.root) || {};
        this.outDir = path_1.default.resolve(store_1.default.root, 'dist/inesatCliShareTypes');
        this.tsconfig = {
            ...this.tsconfig,
            declaration: true,
            emitDeclarationOnly: true,
            //
            outDir: this.outDir,
            rootDir: store_1.default.root,
            // baseUrl: store.config.appSrc
        };
        this.languageService = (0, getTSService_1.getTSService)(this.tsconfig, store_1.default.root);
    }
    setup(op) {
        this.op = op;
        const outDir = path_1.default.resolve(store_1.default.root, this.op.build.typesOutDir);
        if (outDir != this.outDir) {
            this.outDir = outDir;
            this.tsconfig.outDir = outDir;
            this.languageService = (0, getTSService_1.getTSService)(this.tsconfig, store_1.default.root);
        }
        this.op.needClear && fs_extra_1.default.removeSync(this.outDir);
    }
    emit(filename) {
        const output = this.languageService.getEmitOutput(filename);
        try {
            if (!output.emitSkipped) {
                output.outputFiles.forEach(o => {
                    if (o.name.endsWith('.d.ts')) {
                        this.genCode(o);
                    }
                });
            }
        }
        catch (e) {
            console.warn('[inesatCli dts]', filename, e);
        }
    }
    createFile() {
        var _a;
        if (!this.op.build)
            return;
        fs_extra_1.default.ensureDirSync(this.outDir);
        if (this.op.build.lib) {
            const libModName = this.op.build.lib.name || this.op.pkgName;
            let libCode = this.lib.code;
            libCode = (0, transform_1.transformLibName)(libModName, libCode, this.op);
            this.libFilename = path_1.default.resolve(this.outDir, this.op.build.typesLibName);
            // console.log('this.libFilename, libCode', this.libFilename, libCode)
            fs_extra_1.default.writeFileSync(this.libFilename, libCode, 'utf8');
        }
        if ((_a = this.op.mf) === null || _a === void 0 ? void 0 : _a.exposes) {
            const inesatCliModName = this.op.mf.name || '';
            let inesatCliCode = this.lib.code;
            // console.log(this.build.typesInesatCliName, inesatCliModName, inesatCliCode)
            inesatCliCode = (0, transform_1.transformLibName)(inesatCliModName, inesatCliCode, this.op);
            this.inesatCliFilename = path_1.default.resolve(this.outDir, this.op.build.typesInesatCliName);
            // console.log('this.inesatCliFilename', this.inesatCliFilename)
            fs_extra_1.default.writeFileSync(this.inesatCliFilename, inesatCliCode, 'utf8');
        }
        this.destroy();
    }
    genCode(o) {
        if (!this.op.build)
            return;
        if (!this.lib.key.includes(o.name)) {
            let mod = o.name.split(`/${this.op.build.typesOutDir}/`)[1].replace('.d.ts', '');
            if (mod.endsWith('/index')) {
                mod = mod.replace('/index', '');
            }
            // 切换 alias路径
            o.text = (0, transform_1.transformPathImport)(o, this.op);
            // console.log('genCode', o)
            const warpDeclareModuleResult = this.warpDeclareModule(mod, o.text);
            this.lib.code = this.lib.code + warpDeclareModuleResult.code;
            this.lib.code = (0, transform_1.transformImportExposesPath)(this.lib.code, mod, warpDeclareModuleResult.exposeName);
            this.lib.key.push(o.name);
        }
    }
    warpDeclareModule(module, code) {
        code = code.replace(/declare/g, '');
        const { newModule, isExpose } = (0, transform_1.transformExposesPath)(module, this.op);
        return {
            code: `declare module '${newModule}' {\r\n${code}}\r\n`,
            exposeName: isExpose ? newModule : '',
        };
    }
    destroy() {
        this.lib = { code: '', key: [] };
    }
}
exports.default = DTSEmitFile;
//# sourceMappingURL=dts.js.map